# CLAUDE.md

Pure Haskell WebP decoder for JuicyPixels. Decode-only (no encoding).

## Build

```bash
stack build --fast  # build (test that it compiles)
stack test          # run tests
```

Formatter: Ormolu (run via `nix fmt` or `ormolu --mode inplace`).

Do NOT edit `JuicyPixels-webp.cabal` directly — it is generated by hpack from `package.yaml`. Edit `package.yaml` instead.

## Project Layout

```
src/Codec/Picture/WebP.hs           -- public API (stub)
PLAN.md                              -- detailed implementation plan with module structure,
                                        data types, algorithms, phase ordering, and gotchas
```

## Specification Documents

These are the primary references for implementation. They have been cross-checked against the RFCs and are authoritative.

- `docs/webp-format.md` — **WebP container format + VP8L lossless bitstream** (RFC 9649). Covers RIFF chunk parsing, VP8X/ANIM/ANMF/ALPH chunks, and the entire VP8L decode pipeline: prefix codes (Huffman), LZ77, color cache, transforms (predictor, color, subtract-green, color-indexing), subresolution images, and pixel bundling. Includes the canonical Huffman construction algorithm, distance map table (120 entries), LZ77 prefix code tables, and all inverse transform formulas.

- `docs/vp8-bitstream.md` — **VP8 lossy key-frame decoder** (RFC 6386). Covers boolean arithmetic decoder, compressed frame header, macroblock prediction modes, coefficient token tree decoding, dequantization, 4x4 IDCT, Walsh-Hadamard transform, loop filter, and YCbCr-to-RGB conversion. Contains all constant tables needed for implementation: `kf_bmode_probs[10][10][9]` (900 values), `default_coeff_probs[4][8][3][11]` (1056 values), `coeff_update_probs[4][8][3][11]` (1056 values), quantization lookup tables (128 entries each), tree arrays, and context index mappings.

Both docs have section indexes at the top for navigation.

## JuicyPixels Integration

The implementation integrates with JuicyPixels using standard patterns:
- `Image` and `DynamicImage` types for decoded images
- `Metadatas` for EXIF/XMP data
- `decodeWebP` / `decodeWebPWithMetadata` API pattern matching other formats
- Standard error handling with `Either String`

## Critical Implementation Gotchas

These are documented in more detail in the spec docs and PLAN.md but are easy to get wrong:

**VP8L (lossless):**
- Bits are read LSB-first from bytes, but Huffman codes interpret the first-read bit as the MSB of the code (opposite of `ReadBits(n)` which puts first-read bit at LSB)
- Inverse color transform: `red_to_blue` uses the **already-modified** `tmp_red & 0xff`, not the original red
- Code 16 in normal code length code: if used before any nonzero value, repeat 8
- Subresolution images have NO transforms — not even the 0-bit terminator
- Color indexing: palette is subtraction-coded (cumulative add per ARGB component, mod 256)
- Pixel bundling: packed LSB-first into the green channel
- Color cache hash: `(0x1e35a7bd * color) >> (32 - cache_bits)`. Every pixel (literal, backref copy, cache lookup) gets inserted.

**VP8 (lossy):**
- `bool_read_tree` while condition: `while ((i = tree[i + read_bool(...)]) > 0)` — the assignment is inside the condition
- `kf_ymode_tree`: B_PRED at root (code "0"), NOT a linear chain
- IDCT pass order: columns-first then rows (affects bit-exact results)
- Compressed header: `log2_nbr_of_dct_partitions` L(2) comes BEFORE `quant_indices()`
- After DCT_0 token: skip EOB branch (start at `coeff_tree + 2`), but only after an actual DCT_0
- `segment_feature_mode`: RFC text and reference decoder disagree — follow reference decoder (0=delta, 1=abs)
- Loop filter clamp ordering: `clip(w+4) >> 3` (clamp THEN shift), not `clip((w+4)>>3)`
- Loop filter non-HEV: P1/Q1 uses `(Filter1 + 1) >> 1` where `Filter1 = clip(w+4) >> 3`
- Loop filter limits: directly compute `mb_edge_limit = (level+2)*2 + interior_limit`, no intermediate variable
- Two distinct normal filter functions: `subblock_filter` (modifies ≤4 pixels) and `MBfilter` (27/18/9 weighted, 6 pixels)

**Container:**
- VP8X/ANMF reserved fields: "Readers MUST ignore" — don't reject nonzero
- WebP FourCCs are uppercase/mixed (not lowercase per RIFF convention)
- Width/height fields are 1-based (actual = field + 1)
- ALPH with VP8L compression: no RIFF header, no VP8L FourCC, no stream-size, no signature byte, no image-size/alpha/version. Starts at transform-present flag. Extract green channel as alpha.

## Useful Websites

- https://www.rfc-editor.org/rfc/rfc9649 — RFC 9649: WebP Image Format (container + VP8L lossless). The normative spec.
- https://www.rfc-editor.org/rfc/rfc6386 — RFC 6386: VP8 Data Format and Decoding Guide. The normative VP8 lossy spec.
- https://developers.google.com/speed/webp/docs/riff_container — Google's WebP container spec page (mirrors RFC 9649 content).
- https://developers.google.com/speed/webp/docs/webp_lossless_bitstream_specification — Google's VP8L lossless spec page.
- https://chromium.googlesource.com/webm/libwebp/ — libwebp reference implementation (C). Authoritative for resolving spec ambiguities.
- https://chromium.googlesource.com/webm/libwebp/+/refs/heads/main/src/dec/ — libwebp decoder source directory (vp8.c, vp8l.c, alpha.c, etc.).
- https://hackage.haskell.org/package/JuicyPixels — JuicyPixels Hackage page (API docs for Image, DynamicImage, Pixel types).
- https://hackage.haskell.org/package/JuicyPixels/docs/Codec-Picture.html — Codec.Picture module docs (decodeImage, readImage patterns).
- https://hackage.haskell.org/package/JuicyPixels/docs/Codec-Picture-Types.html — Image types, DynamicImage constructors, Pixel typeclass.
- https://hackage.haskell.org/package/vector/docs/Data-Vector-Storable-Mutable.html — MVector docs (primary mutable buffer type for decode).
- https://developers.google.com/speed/webp/gallery1 — WebP sample images for testing.
- https://www.gstatic.com/webp/gallery/ — Additional WebP test images from Google.
